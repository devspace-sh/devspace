---
title: Replacing Pods for Development
sidebar_label: replacePods
---

`replacePods` gives you the option to exchange an already running or just deployed pod with a modified version. This is especially useful if you:

- Need to configure or disable an option on a pod which is not configurable via your helm chart or manifests
- Do not want to use DevSpace for your pipeline and instead only want to use DevSpace for development 
- Want to debug a setup in an already deployed app by exchanging a single pod temporarily with modifications

For example:
```yaml
deployments:
- name: my-app
  helm:
    componentChart: true
    values:
      containers:
      - image: idonotexist:neverexisted # this will create a failing pod
dev:
  # DevSpace will try to find a pod with the given label selector. If found (even if its currently in a failed state)
  # DevSpace will copy the pod, scale down the owning ReplicaSet, Deployment or StatefulSet
  # and create the new modified pod in the cluster.
  replacePods:
    - labelSelector:
        app.kubernetes.io/component: my-app
      replaceImage: ubuntu:latest
      patches:
        - op: add
          path: spec.containers[0].command
          value: ["sleep"]
        - op: add
          path: spec.containers[0].args
          value: ["9999999999"]
        - op: add
          path: spec.containers[0].workingDir
          value: "/workdir"
  # This will create a terminal to the replaced pod
  terminal:
    labelSelector:
      app.kubernetes.io/component: my-app
  # This will sync to the replaced pod's working directory
  sync:
    - labelSelector:
        app.kubernetes.io/component: my-app
```

## How does it work?

Each entry that you specify under `dev.replacePods` will tell DevSpace to search for a pod that should be replaced with the given configuration. If DevSpace finds a pod to replace, it does the following things:
- Copy the pod.metadata and pod.spec of the already running pod
- Scale down the owning ReplicaSet, Deployment or StatefulSet replicas to 0
- Apply the patches to the copied pod 
- Create the copied pod in the cluster

Within the `dev` part of DevSpace, replacing pods is the first step that is executed, which means that all other services such as port-forwarding, sync, log streaming or terminal forwarding will wait until DevSpace has either replaced the pods or already found replaced pods. The services will then target the newly created patched pod instead of the old one.

:::note
DevSpace will automatically recognize changes to the parent Deployment, ReplicaSet or StatefulSet and apply them to the replaced pod automatically in the next run.
:::

## Pod/Container Selection
The following config options are needed to determine the container which should be replaced:
- [`imageName`](#imagename)
- [`labelSelector`](#labelselector)
- [`containerName`](#containername)
- [`namespace`](#namespace)

### `imageName`
The `imageName` option expects a string with the name of an image from the `images` section of the `devspace.yaml`. Using `imageName` tells DevSpace to select the container based on the referenced image that was last built using DevSpace.

:::note
If `imageName` is specified in any of the sync configurations, `devspace dev` will **not** rebuild this image because DevSpace assumes that instead of rebuilding the image, the user wants to use the much faster file synchronization. If you still want to force rebuilding all images, run `devspace dev -b`.
:::

:::note
When you want to select a container with an image that is not defined in your `devspace.yaml`, you generally want to select the right pod using the [`labelSelector`](#labelselector).
:::

:::note 
You can also select an image from a dependency with `dependency1.image1`
:::

#### Example: Select Container by Image Name
```yaml
images:
  backend:
    image: john/devbackend
    build:
      disabled: true
deployments:
- name: app-backend
  helm:
    componentChart: true
    values:
      containers:
      - name: container-0
        image: john/devbackend
dev:
  replacePods:
  - imageName: backend
    replaceImage: ubuntu:latest
    patches:
    - op: add
      path: spec.containers[0].command
      value: ["sleep"]
    - op: add
      path: spec.containers[0].args
      value: ["9999999999"]
    - op: add
      path: spec.containers[0].workingDir
      value: "/workdir"
  terminal:
    imageName: backend
```

### `labelSelector`
The `labelSelector` option expects a key-value map of strings with Kubernetes labels.

:::info
If you are using the `labelSelector` option, you may want to additionally specify the [`containerName` option](#containername) to set the target container.
:::

#### Example: Select Container by Label
```yaml
deployments:
- name: app-backend
  helm:
    componentChart: true
    values:
      containers:
      - name: container-0
        image: idontexist 
dev:
  replacePods:
  - labelSelector:
      app.kubernetes.io/component: app-backend
    containerName: container-0
    replaceImage: ubuntu:latest
    patches:
    - op: add
      path: spec.containers[0].command
      value: ["sleep"]
    - op: add
      path: spec.containers[0].args
      value: ["9999999999"]
    - op: add
      path: spec.containers[0].workingDir
      value: "/workdir"
  sync:
  - labelSelector:
      app.kubernetes.io/component: app-backend
    containerName: container-0
```
**Explanation:**
- The `labelSelector` would select the pod created for the component deployment `app-backend`.

### `containerName`
The `containerName` option expects a string with a container name. This option is used to decide which container should be selected when using the `labelSelector` option because `labelSelector` selects a pod and a pod can have multiple containers.

:::info
The `containerName` option is not required if the pod you are selecting using `imageName` or `labelSelector` has only one container.
:::

### `namespace`
The `namespace` option expects a string with a Kubernetes namespace used to select the container from.

:::warning
It is generally **not** needed (nor recommended) to specify the `namespace` option because by default, DevSpace uses the default namespace of your current kube-context which is usually the one that has been used to deploy your containers to.
:::

## Pod Modifications

### `replaceImage`

`replaceImage` expects a string with the new image name (inclusive tag) that should be used for the selected pod. For example: `replaceImage: my-repo/my-debug-image:1.0`. In addition, DevSpace will also replace the following things:

- **registry.url/repo/name** that corresponds to a `images.*.image`, will be rewritten to `registry.url/repo/name:generated_tag`
- **image(registry.url/repo/name)** that corresponds to a `images.*.image`, will be rewritten to `registry.url/repo/name`
- **imageName(image1)** that corresponds to a `images.*` key, will be rewritten to `registry.url/repo/name:generated_tag`. You can also use dependency images here with `imageName(dependency1.image1)`
- **imageNameImage(image1)** that corresponds to a `images.*` key, will be rewritten to `registry.url/repo/name`. You can also use dependency images here with `imageNameImage(dependency1.image1)`
- **imageNameTag(image1)** that corresponds to a `images.*` key, will be rewritten to `generated_tag`. You can also use dependency images here with `imageNameTag(dependency1.image1)`

### `patches`

`patches` define more generic patches that should be applied to the pod. You can basically modify anything in the pod here. Patch functionality follows JSON Patch([RFC](https://tools.ietf.org/html/rfc6902)) semantics, as implemented by the [yaml-patch](https://github.com/krishicks/yaml-patch) library.

The `patches` option expects a patch object which consists of the following properties:
- `op` stating the patch operation (possible values: `replace`, `add`, `remove`)
- `path` stating a jsonpath or a xpath within the pod (e.g. `metadata.annotations`, `spec.containers.name=backend.env`)
- `value` stating an arbitrary value used by the operation (e.g. a string, an integer, a boolean, a yaml object)

:::warning `op: add` only for arrays
Using `op: add` only works as expected when `path` points to an array value. Using `op: add` to add properties to an object (e.g. `metadata.annotations`) will **not** work and instead replace all existing properties.
:::

:::tip Array Paths
When you want to define a `path` that contains an array (e.g. `spec.containers`), you have two options:

1. Use the index of the array item you want to patch, e.g. `spec.containers[0]`
2. Use a property selector matching the array item(s) you want to patch, e.g. `spec.containers.name=backend`

Using a property selector is often better because it is more resilient and will not cause any issues even if the order of an array's items is changed later on. A property selector is also able to select multiple array items if all of them have the same value for this property.
:::

:::info Value For Replace / Add
If you use the `replace` or `add` operation, `value` is a mandatory property.
:::

:::info
If `value` is defined, the new value must provide the correct type to be used when adding or replacing the existing value found under `path` using the newly provided `value`, e.g. an array must be replaced with an array.
:::

#### Example: Overwrite command and args of a pod
```yaml
dev:
  replacePods:
  - labelSelector:
      app.kubernetes.io/component: app-backend
    containerName: container-0
    patches:
    - op: add
      path: spec.containers[0].command
      value: ["sleep"]
    - op: add
      path: spec.containers[0].args
      value: ["9999999999"]
```

## Reset replaced pods

If you want to reset replaced pods and revert the cluster state to before, you can run 
```
devspace reset pods
```
